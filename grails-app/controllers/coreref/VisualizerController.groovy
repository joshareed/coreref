package coreref

import grails.converters.JSON

/**
 * Provides Visualizer integration.
 */
class VisualizerController extends SecureController {

	/**
	 * Generates a Visualizer expedition file.
	 * Note: SECURE
	 */
    def index = { 
		withProject { project ->
			response.setHeader "Content-disposition", "attachment; filename=${project.id}-viz.xml"
			def config = mongoService['_configs'].find('id': project.id)
			def images = mongoService[project.id].distinct('type', ['class': 'Image'] as com.mongodb.BasicDBObject)
			render(contentType: 'text/xml') {
				comment << "Generated by CoreRef (http://coreref.org)"
				Expedition(name: project.name, root: createLink(controller: 'visualizer', action: 'index', params: [project: project.id], absolute: true) - 'index') {
					images.each { type ->
						Feed(name: type[0].toUpperCase() + type[1..-1] + ' Core Images', parser: 'url', resource: 'CoreRef Image', url: "images/$type") {
							entry(key: 'visualizer.track', type[0].toUpperCase() + type[1..-1] + ' Core Images - ' + project.id)
						}
					}
					config.tracks.findAll { it.key == 'lith' }.each { 
						Feed(name: 'Lithology', parser: 'url', resource: 'CoreRef Lithology', url: "lith") {
							entry(key: 'visualizer.track', 'Lithology - ' + project.id)
						}
					}
					config.tracks.find { it.value.type == 'plot' }?.each { plot ->
						plot.value.series.each { s ->
							Feed(name: s, parser: 'url', resource: 'Physical Property', url: "data/$s".replaceAll(' ', '%20')) {
								entry(key: 'visualizer.track', s + '-' + project.id)
								entry(key: 'dataset.separator', ',')
								entry(key: 'dataset.depth-column', 0)
								entry(key: 'dataset.data-column', 1)
							}
						}
					}
				}
			}
		}
	}
	
	/**
	 * Generates image metadata for a project as JSON.
	 * Note: SECURE
	 */
	def images = {
		withProject { project ->
			def results = mongoService[project.id].findAll('class': 'Image', 'type': (params.opt ?: 'split')).collect { SearchUtils.clean(it) }
			response.setHeader "Content-disposition", "attachment; filename=${project.id}-images.json"
			render(contentType: 'application/json', text: (results as JSON))
		}
	}
	
	/**
	 * Generates lithology metadata for a project as JSON.
	 * Note: SECURE
	 */
	def lith = {
		withProject { project ->
			def results = mongoService[project.id].findAll('class': 'Interval').collect { SearchUtils.clean(it) }
			response.setHeader "Content-disposition", "attachment; filename=${project.id}-lith.json"
			render(contentType: 'application/json', text: (results as JSON))
		}
	}
	
	/**
	 * Generates numerical data tables for a project as CSV.
	 * Note: SECURE
	 */
	def data = {
		withProject { project ->
			String col = params?.opt?.toLowerCase()
			StringBuilder results = new StringBuilder("depth,${col}\n")
			mongoService[project.id].findAll('class': 'Datum', 'type': params.opt).each { doc ->
				results.append(doc.top + "," + (doc[col] ?: '') + "\n")
			}
			response.setHeader "Content-disposition", "attachment; filename=${project.id}-${params.opt}.csv"
			render(contentType: 'text/csv', text: results.toString())
		}
	}
}